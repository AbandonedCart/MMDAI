#extension GL_ARB_separate_shader_objects : enable

uniform mat4 modelViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Camera"; >;
uniform mat4 lightViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Light"; >;
uniform mat4 normalMatrix              : WORLD;
uniform vec3 materialAmbient           : AMBIENT < Object = "Geometry"; >;
uniform vec4 materialDiffuse           : DIFFUSE < Object = "Geometry"; >;
uniform vec3 materialEmissive          : EMISSIVE < Object = "Geometry"; >;
uniform vec3 materialSpecular          : SPECULAR < Object = "Geometry"; >;
uniform float materialShininess        : SPECULARPOWER < Object = "Geometry"; >;
uniform vec3 lightAmbient              : AMBIENT < Object = "Light"; >;
uniform vec3 lightDiffuse              : DIFFUSE < Object = "Light"; >;
uniform vec3 lightSpecular             : SPECULAR < Object = "Light"; >;
uniform vec3 cameraPosition            : POSITION < Object = "Camera"; >;
uniform vec3 lightDirection            : DIRECTION < Object = "Light"; >;
uniform vec4 edgeColor                 : EDGECOLOR;
uniform float edgeWidth                : EDGEWIDTH;

uniform sampler2D mainSampler          : MATERIALTEXTURE;
uniform sampler2D toonSampler          : MATERIALTOONTEXTURE;
uniform sampler2D sphereSampler        : MATERIALSPHEREMAP;
uniform sampler2D depthSampler         : TEXUNIT0;

uniform bool use_texture;
uniform bool use_spheremap;
uniform bool spadd;
uniform bool spsub;

uniform sampler2D boneTransformSampler : BONETRANSFORMTEXTUREVPVL2;
uniform float edgeScaleFactor : EDGESCALEFACTORVPVL2;
uniform int BoneCountVPVL2;
uniform bool use_boneTransformTextureVPVL2;

namespace vpvl2 {

SamplerState defaultSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultToonSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}
SamplerState defaultDepthSamplerState
{
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}

GLSLShader outputPositionSelfShadow {

#if __VERSION__ < 130
#define out varying
#endif

out vec4 vpvl2_outShadowPosition;

vec4 outputPosition(const vec4 position) {
    vec4 newPosition = lightViewProjectionMatrix * vec4(position.xyz, 1.0);
    vpvl2_outShadowPosition = newPosition;
    return modelViewProjectionMatrix * newPosition;
}

} /* outputPositionSelfShadow */

GLSLShader outputPositionZplot {

vec4 outputPosition(const vec4 position) {
    return lightViewProjectionMatrix * vec4(position.xyz, 1.0);
}

} /* outputPositionZplot */

GLSLShader outputPosition {

vec4 outputPosition(const vec4 position) {
    return modelViewProjectionMatrix * vec4(position.xyz, 1.0);
}

} /* outputPosition */

GLSLShader global performTransform {

#if __VERSION__ < 130
#define in attribute
#ifndef texture
#define texture texture2D
#endif
#endif

in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;

const int kBdef1 = 0;
const int kBdef2 = 1;
const int kBdef4 = 2;
const int kSdef  = 3;
const int kQdef  = 4;

mat4 boneTransformMatrix(const float index) {
    float newIndex = index / float(BoneCountVPVL2);
    mat4 matrix = mat4(1);
    vec4 p = texture(boneTransformSampler, vec2(0.0,  newIndex));
    vec4 q = texture(boneTransformSampler, vec2(0.5,  newIndex));
    matrix[0] = vec4(
        1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,
        2.0 * q.x * q.y + 2.0 * q.w * q.z,
        2.0 * q.x * q.z - 2.0 * q.w * q.y,
        0.0
    );
    matrix[1] = vec4(
        2.0 * q.x * q.y - 2.0 * q.w * q.z,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,
        2.0 * q.y * q.z + 2.0 * q.w * q.x,
        0.0
    );
    matrix[2] = vec4(
        2.0 * q.x * q.z + 2.0 * q.w * q.y,
        2.0 * q.y * q.z - 2.0 * q.w * q.x,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y,
        0.0
    );
    matrix[3] = p;
    return matrix;
}

vec4 performSkinning(const vec3 position3, const float base, const int type) {
    vec4 position = vec4(position3, base);
    bool bdef4 = any(bvec2(type == kBdef4, type == kQdef));
    bool bdef2 = any(bvec2(type == kBdef2, type == kSdef));
    if (bdef4) {
        mat4 matrix1 = boneTransformMatrix(vpvl2_inBoneIndices.x);
        mat4 matrix2 = boneTransformMatrix(vpvl2_inBoneIndices.y);
        mat4 matrix3 = boneTransformMatrix(vpvl2_inBoneIndices.z);
        mat4 matrix4 = boneTransformMatrix(vpvl2_inBoneIndices.w);
        return vpvl2_inBoneWeights.xxxx * (matrix1 * position)
             + vpvl2_inBoneWeights.yyyy * (matrix2 * position)
             + vpvl2_inBoneWeights.zzzz * (matrix3 * position)
             + vpvl2_inBoneWeights.wwww * (matrix4 * position);
    }
    else if (bdef2) {
        mat4 matrix1 = boneTransformMatrix(vpvl2_inBoneIndices.x);
        mat4 matrix2 = boneTransformMatrix(vpvl2_inBoneIndices.y);
        vec4 p1 = matrix2 * position;
        vec4 p2 = matrix1 * position;
        return mix(p1, p2, vpvl2_inBoneWeights.x);
    }
    else if (type == kBdef1) {
        mat4 matrix = boneTransformMatrix(vpvl2_inBoneIndices.x);
        return matrix * position;
    }
    return position;
}

vec4 performPositionTransform(const vec4 position) {
    if (use_boneTransformTextureVPVL2) {
        return performSkinning(position.xyz, 1.0, int(position.w));
    }
    return vec4(position.xyz, 1.0);
}

vec4 performNormalTransform(const vec4 normal, const vec4 position) {
    if (use_boneTransformTextureVPVL2) {
        return performSkinning(normal.xyz, 0.0, int(position.w));
    }
    return vec4(normal.xyz, 0.0);
}

vec4 performEdgeTransform(const vec4 position, const vec4 normal) {
    if (use_boneTransformTextureVPVL2) {
        int type         = int(position.w);
        vec4 newPosition = performSkinning(position.xyz, 1.0, type);
        vec4 newNormal   = performSkinning(normal.xyz,   0.0, type);
        newPosition.xyz += newNormal.xyz * normal.www * vec3(edgeWidth * edgeScaleFactor);
        return newPosition;
    }
    return vec4(position.xyz, 1.0);
}

} /* performTransform */

GLSLShader applyTexture {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
    vec4 newColor = color;
    if (use_texture) {
        newColor *= texture(mainSampler, texcoord.xy);
    }
    if (use_spheremap) {
        if (spadd) {
            newColor.rgb += texture(sphereSampler, texcoord.zw).rgb;
        }
        else if (spsub) {
            newColor.rgb *= texture(sphereSampler, uva1.xy).rgb;
        }
        else {
            newColor.rgb *= texture(sphereSampler, texcoord.zw).rgb;
        }
    }
    return newColor;
}

} /* applyTexture */

GLSLShader noApplyTexture {

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
     return color;
}

} /* noApplyTexture */

GLSLShader applyToon {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const vec2 kToonTexCoord = vec2(0.0, 1.0);
const vec3 kWhiteColor = vec3(1.0);

vec4 applyToon(const vec4 color, const vec3 normal) {
    vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
    vec3 toonColor = toonColorRGBA.rgb;
    float lightNormal = dot(normal, -lightDirection.xyz);
    float w = clamp(lightNormal * 16.0 + 0.5, 0.0, 1.0);
    return vec4(color.rgb * (toonColor + (kWhiteColor - toonColor) * vec3(w)), color.a);
}

} /* applyToon */

GLSLShader noApplyToon {

vec4 applyToon(const vec4 color, const vec3 normal) {
     return color;
}

} /* noApplyToon */

GLSLShader getShadowFactor {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const float kEpsilonBias = 0.00001;

float getShadowFactor(const vec4 position) {
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vec2((shadowPosition.xy * 0.5) + 0.5);
#if 0 /* VSM */
    vec2 depthSample = texture(depthSampler, shadowCoord).rg;
    float sigma = depthSample.y - depthSample.x * depthSample.x + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = clamp(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)), 0.0, 1.0);
#else
    float depthSample = texture(depthSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

} /* getShadowFactor */

GLSLShader applyToonSelfShadow {

#if __VERSION__ < 130
#define in varying
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

in vec4 vpvl2_outShadowPosition;
float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec3 normal) {
    const vec2 kToonTexCoord = vec2(0.0, 1.0);
    vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
    vec3 toonColor = toonColorRGBA.rgb;
    vec3 shadowColor = color.rgb * toonColor;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - getShadowFactor(vpvl2_outShadowPosition)), color.a);
}

} /* applyToonSelfShadow */

GLSLShader applySelfShadow {

#if __VERSION__ < 130
#define in varying
#endif

in vec4 vpvl2_outShadowPosition;

float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec3 normal) {
    vec3 shadowColor = color.rgb * materialAmbient;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - getShadowFactor(vpvl2_outShadowPosition)), color.a);
}

} /* applySelfShadow */

GLSLShader mainObjectVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec2 vpvl2_inTexCoord;
in vec4 vpvl2_inUVA1;
in vec4 vpvl2_inUVA2;
in vec4 vpvl2_inUVA3;
in vec4 vpvl2_inUVA4;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec4 vpvl2_outColor;
out vec3 vpvl2_outEyeView;
out vec3 vpvl2_outNormal;

vec4 performPositionTransform(const vec4 position);
vec4 performNormalTransform(const vec4 normal, const vec4 position);
vec4 outputPosition(const vec4 position);

const vec2 kHalf2 = vec2(0.5);
const vec2 kOne2  = vec2(1.0);
const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);
const vec4 kZero4 = vec4(0.0);
const vec4 kOne4  = vec4(1.0);

void main() {
    vec4 position = performPositionTransform(vpvl2_inPosition);
    vec3 normal   = (normalMatrix * performNormalTransform(vpvl2_inNormal, vpvl2_inPosition)).xyz;
    vec3 ambient  = clamp(materialAmbient * lightAmbient + materialEmissive, kZero3, kOne3);
    vec4 diffuse  = clamp(materialDiffuse * vec4(lightDiffuse, 1.0), kZero4, kOne4);
    vpvl2_outPosition    = position;
    vpvl2_outTexCoord.xy = vpvl2_inTexCoord;
    vpvl2_outUVA1        = vpvl2_inUVA1;
    vpvl2_outUVA2        = vpvl2_inUVA2;
    vpvl2_outUVA3        = vpvl2_inUVA3;
    vpvl2_outUVA4        = vpvl2_inUVA4;
    vpvl2_outColor       = vec4(clamp(ambient + dot(vpvl2_inNormal.xyz, -lightDirection) * diffuse.rgb, kZero3, kOne3), diffuse.a);
    vpvl2_outEyeView     = cameraPosition.xyz - position.xyz;
    vpvl2_outNormal      = vpvl2_inNormal.xyz;
    if (use_spheremap) {
        vpvl2_outTexCoord.zw = -normal.xy * kHalf2 + kHalf2;
    }
    else {
        vpvl2_outTexCoord.zw = kOne2 + vec2(dot(lightDirection.xyz, -normal)) * kHalf2;
    }
    vec4 newPosition  = outputPosition(position);
    vpvl2_outPosition = newPosition;
    gl_Position       = newPosition;
}

} /* GLSLShader mainObjectVS */

GLSLShader global noPixelColor {

const vec4 kZero4 = vec4(0.0);

vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{                      
    return kZero4;
}

} /* noPixelColor */

GLSLShader outputPixelColor {

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1);
vec4 applyToon(const vec4 color, const vec3 normal);

const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);


vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    vec4 newColor = applyToon(applyTexture(color, texcoord, uva1), normal);
    vec3 halfVector = normalize(eyeView - lightDirection);
    vec3 specular = clamp(materialSpecular * lightSpecular, kZero3, kOne3);
    float hdotn = max(dot(halfVector, normal), 0.0);
    newColor.rgb += specular * vec3(pow(hdotn, max(materialShininess, 1.0)));
    // newColor.a *= opacity;
    return newColor;
}

} /* outputPixelColor */


GLSLShader outputEdgeColor {

vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    return edgeColor;
}

} /* outputEdgeColor */

GLSLShader outputShadowColor {


vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    return vec4(materialAmbient, materialDiffuse.a);
}

} /* outputShadowColor */

GLSLShader outputZplot {

#if __VERSION__ < 130
#define in varying
#endif

vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    float depth = position.z / position.w;
    return vec4(depth, depth * depth, 0, 1);
}

} /* outputZplot */

GLSLShader mainObjectPS {

#if __VERSION__ < 130
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#else
out vec4 vpvl2_outPixelColor;
#endif
in vec4 vpvl2_outPosition;
in vec4 vpvl2_outTexCoord;
in vec4 vpvl2_outColor;
in vec4 vpvl2_outUVA1;
in vec4 vpvl2_outUVA2;
in vec4 vpvl2_outUVA3;
in vec4 vpvl2_outUVA4;
in vec3 vpvl2_outEyeView;
in vec3 vpvl2_outNormal;

vec4 outputPixelColor(const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec3 eyeView,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4);

void main() {
    vpvl2_outPixelColor = outputPixelColor(vpvl2_outPosition,
                                           normalize(vpvl2_outNormal),
                                           vpvl2_outTexCoord,
                                           vpvl2_outColor,
                                           normalize(vpvl2_outEyeView),
                                           vpvl2_outUVA1,
                                           vpvl2_outUVA2,
                                           vpvl2_outUVA3,
                                           vpvl2_outUVA4);
}

} /* GLSLShader mainObjectPS */

GLSLShader mainEdgeVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;

out vec4 vpvl2_outPosition;
out vec4 vpvl2_outColor;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec3 vpvl2_outNormal;
out vec3 vpvl2_outEyeView;

const vec4 kZero4 = vec4(0.0);
const vec3 kZero3 = vec3(0.0);

vec4 performEdgeTransform(const vec4 position, const vec4 normal);
vec4 outputPosition(const vec4 position);

void main() {
    vec4 newPosition = outputPosition(performEdgeTransform(vpvl2_inPosition, vpvl2_inNormal));
    vpvl2_outPosition = newPosition;
    vpvl2_outTexCoord = kZero4;
    vpvl2_outColor    = kZero4;
    vpvl2_outUVA1     = kZero4;
    vpvl2_outUVA2     = kZero4;
    vpvl2_outUVA3     = kZero4;
    vpvl2_outUVA4     = kZero4;
    vpvl2_outEyeView  = kZero3;
    vpvl2_outNormal   = vpvl2_inNormal.xyz;
    gl_Position       = newPosition;
}

} /* GLSLShader mainEdgeVS */

GLSLShader mainVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;

out vec4 vpvl2_outPosition;
out vec4 vpvl2_outColor;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec3 vpvl2_outNormal;
out vec3 vpvl2_outEyeView;

const vec4 kZero4 = vec4(0.0);
const vec3 kZero3 = vec3(0.0);

vec4 performPositionTransform(const vec4 position);
vec4 outputPosition(const vec4 position);

void main() {
    vec4 newPosition  = outputPosition(performPositionTransform(vpvl2_inPosition));
    vpvl2_outPosition = newPosition;
    vpvl2_outTexCoord = kZero4;
    vpvl2_outColor    = kZero4;
    vpvl2_outUVA1     = kZero4;
    vpvl2_outUVA2     = kZero4;
    vpvl2_outUVA3     = kZero4;
    vpvl2_outUVA4     = kZero4;
    vpvl2_outEyeView  = kZero3;
    vpvl2_outNormal   = kZero3;
    gl_Position       = newPosition;
}

} /* GLSLShader mainVS */

} /* namespace vpvl2 */

technique vpvl2_techniques_Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object1 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object2 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object3 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object4 {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object5 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object6 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object7 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object8 {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS1 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = { 
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS2 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS3 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS4 {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS5 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS6 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS7 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS8 {
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupObject"> = vpvl2::outputPositionSelfShadow;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Edge < MMDPass = "edge"; > {
    pass DrawPass_Edge {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainEdgeVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        VertexProgram<"transformGroupEdge"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupEdge"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupEdge"> = vpvl2::outputEdgeColor;
    }
}

technique vpvl2_techniques_Shadow < MMDPass = "shadow"; > {
    pass DrawPass_Shadow {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        VertexProgram<"transformGroupShadow"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupShadow"> = vpvl2::outputPosition;
        FragmentProgram<"fragmentGroupShadow"> = vpvl2::outputShadowColor;
    }
}

technique vpvl2_techniques_Zplot < MMDPass = "zplot"; > {
    pass DrawPass_Zplot {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        VertexProgram<"transformGroupZplot"> = vpvl2::performTransform;
        VertexProgram<"vertexGroupZplot"> = vpvl2::outputPositionZplot;
        FragmentProgram<"fragmentGroupZplot"> = vpvl2::outputZplot;
    }
}

