uniform mat4 modelViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Camera"; >;
uniform mat4 lightViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Light"; >;
uniform mat4 normalMatrix              : WORLD;
uniform vec3 materialAmbient           : AMBIENT < Object = "Geometry"; >;
uniform vec4 materialDiffuse           : DIFFUSE < Object = "Geometry"; >;
uniform vec3 materialEmissive          : EMISSIVE < Object = "Geometry"; >;
uniform vec3 materialSpecular          : SPECULAR < Object = "Geometry"; >;
uniform float materialShininess        : SPECULARPOWER < Object = "Geometry"; >;
uniform vec3 lightAmbient              : AMBIENT < Object = "Light"; >;
uniform vec3 lightDiffuse              : DIFFUSE < Object = "Light"; >;
uniform vec3 lightSpecular             : SPECULAR < Object = "Light"; >;
uniform vec3 cameraPosition            : _POSITION < Object = "Camera"; >;
uniform vec3 lightDirection            : DIRECTION < Object = "Light"; >;
uniform vec4 edgeColor                 : EDGECOLOR;

uniform sampler2D mainSampler          : MATERIALTEXTURE;
uniform sampler2D toonSampler          : MATERIALTOONTEXTURE;
uniform sampler2D sphereSampler        : MATERIALSPHEREMAP;
uniform sampler2D depthSampler         : TEXUNIT0;

uniform bool use_spheremap;
uniform bool spadd;
uniform bool spsub;

// uniform mat4 boneMatrices[64] : BONEMATRICES;

GLSLShader {
#ifdef GL_ES
precision highp float;
#endif
}

namespace vpvl2 {

SamplerState defaultSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultToonSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}
SamplerState defaultDepthSamplerState
{
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}

GLSLShader performTransformGPU {

#if __VERSION__ < 130
#define in attribute
#endif

in vec4 inBoneIndices;
in vec4 inBoneWeights;

const int kBdef1 = 0;
const int kBdef2 = 1;
const int kBdef4 = 2;
const int kSdef  = 3;
const int kQdef  = 4;

vec4 performTransform(const vec3 position3, const int type) {
    vec4 position = vec4(position3, 1.0);
    bvec2 bdef2   = bvec2(type == kBdef2, type == kSdef);
    bvec2 bdef4   = bvec2(type == kBdef4, type == kQdef);
    if (any(bdef4)) {
        mat4 matrix1 = boneMatrices[int(inBoneIndices.x)];
        mat4 matrix2 = boneMatrices[int(inBoneIndices.y)];
        mat4 matrix3 = boneMatrices[int(inBoneIndices.z)];
        mat4 matrix4 = boneMatrices[int(inBoneIndices.w)];
        float weight1 = inBoneWeights.x;
        float weight2 = inBoneWeights.y;
        float weight3 = inBoneWeights.z;
        float weight4 = inBoneWeights.w;
        return weight1 * (matrix1 * position)
                       + weight2 * (matrix2 * position)
                       + weight3 * (matrix3 * position)
                       + weight4 * (matrix4 * position);
    }
    else if (any(bdef2)) {
        mat4 matrix1 = boneMatrices[int(inBoneIndices.x)];
        mat4 matrix2 = boneMatrices[int(inBoneIndices.y)];
        float weight = inBoneWeights.x;
        vec4 p1 = matrix2 * position;
        vec4 p2 = matrix1 * position;
        return p1 + (p2 - p1) * weight;
    }
    else if (type == kBdef1) {
        mat4 matrix = boneMatrices[int(inBoneIndices.x)];
        return matrix * position;
    }
    return position;
}

} /* performTransform */

GLSLShader performTransformCPU {

vec4 performTransform(const vec3 position3, const int type) {
    return vec4(position3, 1.0);
}

} /* performTransform */

GLSLShader outputPositionSelfShadow {

#if __VERSION__ < 130
#define out varying
#endif

out vec4 outShadowPosition;

vec4 performTransform(const vec3 position, const int type);

void outputPosition(const vec4 position) {
    vec4 newPosition = performTransform(position.xyz, int(position.w));
    outShadowPosition = lightViewProjectionMatrix * newPosition;
    gl_Position = modelViewProjectionMatrix * newPosition;
}

} /* outputPositionSelfShadow */

GLSLShader outputPositionZplot {

#if __VERSION__ < 130
#define out varying
#endif

out vec4 outPosition;

vec4 performTransform(const vec3 position, const int type);

void outputPosition(const vec4 position) {
    vec4 result = lightViewProjectionMatrix * performTransform(position.xyz, int(position.w));
    outPosition = result;
    gl_Position = result;
}

} /* outputPositionZplot */

GLSLShader outputPosition {

vec4 performTransform(const vec3 position, const int type);

void outputPosition(const vec4 position) {
    gl_Position = modelViewProjectionMatrix * performTransform(position.xyz, int(position.w));
}

} /* outputPosition */

GLSLShader applyTexture {

#if __VERSION__ < 130
#define in varying
#define texture(samp, uv) texture2D((samp), (uv))
#endif

in vec4 outTexCoord;

vec4 applyTexture(const vec4 color) {
    return color * texture(mainSampler, outTexCoord.xy);
}

} /* applyTexture */

GLSLShader noApplyTexture {

vec4 applyTexture(const vec4 color) {
     return color;
}

} /* noApplyTexture */

GLSLShader applySphereMap {

#if __VERSION__ < 130
#define in varying
#define texture(samp, uv) texture2D((samp), (uv))
#endif

in vec4 outTexCoord;
in vec4 outUVA1;

vec4 applySphereMap(const vec4 color) {
    if (spadd) {
        return vec4(color.rgb + texture(sphereSampler, outTexCoord.zw).rgb, color.a);
    }
    else if (spsub) {
        return vec4(color.rgb * texture(sphereSampler, outUVA1.xy).rgb, color.a);
    }
    else {
        return vec4(color.rgb * texture(sphereSampler, outTexCoord.zw).rgb, color.a);
    }
}

} /* applySphereMap */

GLSLShader noApplySphereMap {

vec4 applySphereMap(const vec4 color) {
     return color;
}

} /* noApplySphereMap */

GLSLShader applyToon {

#if __VERSION__ < 130
#define texture(samp, uv) texture2D((samp), (uv))
#endif

const float kOne = 1.0;
const float kHalf = 0.5;
const float kZero = 0.0;
const vec2 kToonTexCoord = vec2(kZero, kOne);
const vec3 kWhiteColor = vec3(kOne);

vec4 applyToon(const vec4 color, const vec3 normal) {
    vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
    vec3 toonColor = toonColorRGBA.rgb;
    float lightNormal = dot(normal, -lightDirection.xyz);
    float w = clamp(lightNormal * 16.0 + kHalf, kZero, kOne);
    return vec4(color.rgb * (toonColor + (kWhiteColor - toonColor) * w), color.a);
}

} /* applyToon */

GLSLShader noApplyToon {

vec4 applyToon(const vec4 color, const vec3 normal) {
     return color;
}

} /* noApplyToon */

GLSLShader getShadowFactor {

#if __VERSION__ < 130
#define texture(samp, uv) texture2D((samp), (uv))
#endif

const float kHalf = 0.5;
const float kEpsilonBias = 0.00001;

float getShadowFactor(const vec4 position) {
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vec2((shadowPosition.xy * kHalf) + kHalf);
#if 0 /* VSM */
    vec2 depthSample = texture(depthSampler, shadowCoord).rg;
    float sigma = depthSample.y - depthSample.x * depthSample.x + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = clamp(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)), 0.0, 1.0);
#else
    float depthSample = texture(depthSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

} /* getShadowFactor */

GLSLShader applyToonSelfShadow {

#if __VERSION__ < 130
#define in varying
#define texture(samp, uv) texture2D((samp), (uv))
#endif

in vec4 outShadowPosition;
const float kOne = 1.0;
const float kZero = 0.0;

float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec3 normal) {
    const vec2 kToonTexCoord = vec2(kZero, kOne);
    vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
    vec3 toonColor = toonColorRGBA.rgb;
    vec3 shadowColor = color.rgb * toonColor;
    return vec4(shadowColor + (color.rgb - shadowColor) * (kOne - getShadowFactor(outShadowPosition)), color.a);
}

} /* applyToonSelfShadow */

GLSLShader applySelfShadow {

#if __VERSION__ < 130
#define in varying
#endif

in vec4 outShadowPosition;
const float kOne = 1.0;

float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec3 normal) {
    vec3 shadowColor = color.rgb * materialAmbient;
    return vec4(shadowColor + (color.rgb - shadowColor) * (kOne - getShadowFactor(outShadowPosition)), color.a);
}

} /* applySelfShadow */

GLSLShader mainObjectVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#endif
in vec3 inPosition;
in vec3 inNormal;
in vec2 inTexCoord;
in vec4 inUVA1;
out vec4 outColor;
out vec4 outTexCoord;
out vec4 outUVA1;
out vec3 outEyeView;
out vec3 outNormal;

const float kOne = 1.0;
const float kHalf = 0.5;
const float kZero = 0.0;

void outputPosition(const vec4 position);

vec3 saturate3(vec3 value) {
    return clamp(value, vec3(kZero), vec3(kOne));
}
vec4 saturate4(vec4 value) {
    return clamp(value, vec4(kZero), vec4(kOne));
}

vec2 makeSphereMap(const vec3 normal) {
    return vec2(-normal.x * kHalf + kHalf, -normal.y * kHalf + kHalf);
}

vec2 calculateToon(const vec3 normal) {
    return (vec3(kOne, kOne, kOne) + dot(lightDirection.xyz, -normal) * kHalf).xy;
}

void main() {
    vec4 position = vec4(inPosition, kOne);
    vec3 normal = (normalMatrix * vec4(inNormal, 0)).xyz;
    vec3 ambient = saturate3(materialAmbient * lightAmbient + materialEmissive);
    vec4 diffuse = saturate4(materialDiffuse * vec4(lightDiffuse, kOne));
    outEyeView = cameraPosition.xyz - inPosition;
    outNormal = inNormal;
    outColor.rgb = saturate3(ambient + dot(inNormal, -lightDirection) * diffuse.rgb);
    outColor.a = diffuse.a;
    outTexCoord.xy = inTexCoord;
    outTexCoord.zw = use_spheremap ? makeSphereMap(normal) : calculateToon(normal);
    outUVA1 = inUVA1;
    outputPosition(position);
}

} /* GLSLShader mainObjectVS */

GLSLShader outputPixelColor {

#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif
in vec4 outColor;
in vec3 outEyeView;
in vec3 outNormal;

const float kOne = 1.0;
const float kZero = 0.0;

vec4 applyTexture(const vec4 color);
vec4 applySphereMap(const vec4 color);
vec4 applyToon(const vec4 color, const vec3 normal);

vec3 saturate3(vec3 value) {
    return clamp(value, vec3(kZero), vec3(kOne));
}

void outputPixelColor() {
    vec3 normal = normalize(outNormal);
    vec4 color = applyToon(applySphereMap(applyTexture(outColor)), normal);
    vec3 halfVector = normalize(normalize(outEyeView) - lightDirection);
    vec3 specular = saturate3(materialSpecular * lightSpecular);
    float hdotn = max(dot(halfVector, normal), kZero);
    color.rgb += specular * pow(hdotn, max(materialShininess, kOne));
    // color.a *= opacity;
    outPixelColor = color;
}

} /* outputPixelColor */


GLSLShader outputEdgeColor {

#if __VERSION__ < 130
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif

void outputPixelColor() {
    vec4 color = edgeColor;
    // color.a *= opacity;
    outPixelColor = color;
}

} /* outputEdgeColor */

GLSLShader outputShadowColor {

#if __VERSION__ < 130
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif

void outputPixelColor() {
    vec4 color = vec4(materialAmbient, materialDiffuse.a);
    // color.a *= opacity;
    outPixelColor = color;
}

} /* outputShadowColor */

GLSLShader outputZplot {

#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif

in vec4 outPosition;

void outputPixelColor() {
    float depth = outPosition.z / outPosition.w;
    vec4 color = vec4(depth, depth * depth, 0, 1);
    // color.a *= opacity;
    outPixelColor = color;
}

} /* outputZplot */

GLSLShader mainObjectPS {

void outputPixelColor();

void main() {
    outputPixelColor();
}

} /* GLSLShader mainObjectPS */

GLSLShader mainEdgeVS {

#if __VERSION__ < 130
#define in attribute
#endif
in vec3 inPosition;

const float kOne = 1.0;

void outputPosition(const vec4 position);

void main() {
    vec4 position = vec4(inPosition, kOne);
    outputPosition(position);
}

} /* GLSLShader mainEdgeVS */

GLSLShader mainZplotVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#endif
in vec3 inPosition;
out vec4 outPosition;

const float kOne = 1.0;

void outputPosition(const vec4 position);

void main() {
    vec4 position = vec4(inPosition, kOne);
    outputPosition(position);
}

} /* GLSLShader ZplotVS */

} /* namespace vpvl2 */

technique vpvl2_techniques_Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applySphereMap,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::applySphereMap,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applySphereMap,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applySphereMap,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = { 
            vpvl2::applyTexture,
            vpvl2::applySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::applySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::applySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition)    = 0;
    Attribute(inNormal)      = 1;
    Attribute(inTexCoord)    = 2;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    Attribute(inUVA1)        = 5;
    pass DrawPass {
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionSelfShadow,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplySphereMap,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        FragmentProgram<"color"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Edge < MMDPass = "edge"; > {
    Attribute(inPosition)    = 0;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    pass DrawPass {
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainEdgeVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        FragmentProgram<"color"> = vpvl2::outputEdgeColor;
    }
}

technique vpvl2_techniques_Shadow < MMDPass = "shadow"; > {
    Attribute(inPosition)    = 0;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    pass DrawPass {
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPosition,
            vpvl2::mainEdgeVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        FragmentProgram<"color"> = vpvl2::outputShadowColor;
    }
}

technique vpvl2_techniques_Zplot < MMDPass = "zplot"; > {
    Attribute(inPosition)    = 0;
    Attribute(inBoneIndices) = 3;
    Attribute(inBoneWeights) = 4;
    pass DrawPass {
        VertexProgram = {
            vpvl2::performTransformGPU,
            vpvl2::outputPositionZplot,
            vpvl2::mainZplotVS
        };
        FragmentProgram = vpvl2::mainObjectPS;
        FragmentProgram<"color"> = vpvl2::outputZplot;
    }
}
