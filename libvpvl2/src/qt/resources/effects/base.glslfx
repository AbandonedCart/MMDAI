#extension GL_ARB_separate_shader_objects : enable

uniform mat4 modelViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Camera"; >;
uniform mat4 lightViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Light"; >;
uniform mat4 normalMatrix              : WORLD;
uniform vec3 materialAmbient           : AMBIENT < Object = "Geometry"; >;
uniform vec4 materialDiffuse           : DIFFUSE < Object = "Geometry"; >;
uniform vec3 materialEmissive          : EMISSIVE < Object = "Geometry"; >;
uniform vec3 materialSpecular          : SPECULAR < Object = "Geometry"; >;
uniform float materialShininess        : SPECULARPOWER < Object = "Geometry"; >;
uniform vec3 lightAmbient              : AMBIENT < Object = "Light"; >;
uniform vec3 lightDiffuse              : DIFFUSE < Object = "Light"; >;
uniform vec3 lightSpecular             : SPECULAR < Object = "Light"; >;
uniform vec3 cameraPosition            : POSITION < Object = "Camera"; >;
uniform vec3 lightDirection            : DIRECTION < Object = "Light"; >;
uniform vec4 edgeColor                 : EDGECOLOR;
uniform float edgeWidth                : EDGEWIDTH;

uniform sampler2D mainSampler          : MATERIALTEXTURE;
uniform sampler2D toonSampler          : MATERIALTOONTEXTURE;
uniform sampler2D sphereSampler        : MATERIALSPHEREMAP;
uniform sampler2D depthSampler         : TEXUNIT0;

uniform bool use_texture;
uniform bool use_spheremap;
uniform bool spadd;
uniform bool spsub;

uniform sampler2D boneTransformSampler : BONETRANSFORMTEXTUREVPVL2;
uniform float edgeScaleFactor : EDGESCALEFACTORVPVL2;
uniform int BoneCountVPVL2;
uniform bool use_boneTransformTextureVPVL2;

namespace vpvl2 {

SamplerState defaultSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultToonSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}
SamplerState defaultDepthSamplerState
{
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}

GLSLShader global performTransform {

#if __VERSION__ < 130
#ifndef texture
#define texture texture2D
#endif
#endif

const mat4 kIdenticalMatrix = mat4(1.0);
const int kBdef1 = 0;
const int kBdef2 = 1;
const int kBdef4 = 2;
const int kSdef  = 3;
const int kQdef  = 4;

mat4 boneTransformMatrix(const float index) {
    float newIndex = index / float(BoneCountVPVL2);
    mat4 matrix = kIdenticalMatrix;
    vec4 p = texture(boneTransformSampler, vec2(0.0,  newIndex));
    vec4 q = texture(boneTransformSampler, vec2(0.5,  newIndex));
    matrix[0] = vec4(
        1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,
        2.0 * q.x * q.y + 2.0 * q.w * q.z,
        2.0 * q.x * q.z - 2.0 * q.w * q.y,
        0.0
    );
    matrix[1] = vec4(
        2.0 * q.x * q.y - 2.0 * q.w * q.z,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,
        2.0 * q.y * q.z + 2.0 * q.w * q.x,
        0.0
    );
    matrix[2] = vec4(
        2.0 * q.x * q.z + 2.0 * q.w * q.y,
        2.0 * q.y * q.z - 2.0 * q.w * q.x,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y,
        0.0
    );
    matrix[3] = p;
    return matrix;
}

vec4 performSkinning(const vec3 origin3, const vec4 boneIndices, const vec4 boneWeights, const float base, const int type) {
    vec4 origin = vec4(origin3, base);
    bool bdef4    = any(bvec2(type == kBdef4, type == kQdef));
    bool bdef2    = any(bvec2(type == kBdef2, type == kSdef));
    if (bdef4) {
        mat4 matrix1 = boneTransformMatrix(boneIndices.x);
        mat4 matrix2 = boneTransformMatrix(boneIndices.y);
        mat4 matrix3 = boneTransformMatrix(boneIndices.z);
        mat4 matrix4 = boneTransformMatrix(boneIndices.w);
        return boneWeights.xxxx * (matrix1 * origin)
             + boneWeights.yyyy * (matrix2 * origin)
             + boneWeights.zzzz * (matrix3 * origin)
             + boneWeights.wwww * (matrix4 * origin);
    }
    else if (bdef2) {
        mat4 matrix1 = boneTransformMatrix(boneIndices.x);
        mat4 matrix2 = boneTransformMatrix(boneIndices.y);
        vec4 p1 = matrix2 * origin;
        vec4 p2 = matrix1 * origin;
        return mix(p1, p2, boneWeights.x);
    }
    else if (type == kBdef1) {
        mat4 matrix = boneTransformMatrix(boneIndices.x);
        return matrix * origin;
    }
    return origin;
}

vec4 performPositionTransform(const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        return performSkinning(origin.xyz, boneIndices, boneWeights, 1.0, int(origin.w));
    }
    return vec4(origin.xyz, 1.0);
}

vec4 performNormalTransform(const vec4 normal, const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        return performSkinning(normal.xyz, boneIndices, boneWeights, 0.0, int(origin.w));
    }
    return vec4(normal.xyz, 0.0);
}

vec4 performEdgeTransform(const vec4 origin, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        int type         = int(origin.w);
        vec4 newPosition = performSkinning(origin.xyz, boneIndices, boneWeights, 1.0, type);
        vec4 newNormal   = performSkinning(normal.xyz,   boneIndices, boneWeights, 0.0, type);
        newPosition.xyz += newNormal.xyz * normal.www * vec3(edgeWidth * edgeScaleFactor);
        return newPosition;
    }
    return vec4(origin.xyz, 1.0);
}

} /* performTransform */

GLSLShader applyTexture {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
    vec4 newColor = color;
    if (use_texture) {
        newColor *= texture(mainSampler, texcoord.xy);
    }
    if (use_spheremap) {
        if (spadd) {
            newColor.rgb += texture(sphereSampler, texcoord.zw).rgb;
        }
        else if (spsub) {
            newColor.rgb *= texture(sphereSampler, uva1.xy).rgb;
        }
        else {
            newColor.rgb *= texture(sphereSampler, texcoord.zw).rgb;
        }
    }
    return newColor;
}

} /* applyTexture */

GLSLShader noApplyTexture {

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
     return color;
}

} /* noApplyTexture */

GLSLShader applyToon {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const vec2 kToonTexCoord = vec2(0.0, 1.0);
const vec3 kWhiteColor = vec3(1.0);

vec4 applyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor = texture(toonSampler, kToonTexCoord);
    float w = clamp(dot(normal, -lightDirection.xyz) * 16.0 + 0.5, 0.0, 1.0);
    return vec4(color.rgb * (toonColor.rgb + (kWhiteColor - toonColor.rgb) * vec3(w)), color.a);
}

} /* applyToon */

GLSLShader noApplyToon {

vec4 applyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
     return color;
}

} /* noApplyToon */

GLSLShader getShadowFactor {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const float kEpsilonBias = 0.00001;

float getShadowFactor(const vec4 position) {
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vec2((shadowPosition.xy * 0.5) + 0.5);
#if 0 /* VSM */
    vec2 depthSample = texture(depthSampler, shadowCoord).rg;
    float sigma = depthSample.y - depthSample.x * depthSample.x + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = clamp(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)), 0.0, 1.0);
#else
    float depthSample = texture(depthSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

} /* getShadowFactor */

GLSLShader applyToonSelfShadow {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const vec2 kToonTexCoord = vec2(0.0, 1.0);

float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor   = texture(toonSampler, kToonTexCoord);
    vec3 shadowColor = color.rgb * toonColor.rgb;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - getShadowFactor(shadowPosition)), color.a);
}

} /* applyToonSelfShadow */

GLSLShader applySelfShadow {

float getShadowFactor(const vec4 position);

vec4 applyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec3 shadowColor = color.rgb * materialAmbient;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - getShadowFactor(shadowPosition)), color.a);
}

} /* applySelfShadow */

GLSLShader handleVertex {

const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);
const vec4 kZero4 = vec4(0.0);
const vec4 kOne4  = vec4(1.0);

void handleVertex(const vec4 origin,
                  inout vec4 position,
                  inout vec3 normal,
                  inout vec4 texcoord,
                  inout vec4 color,
                  inout vec4 uva1,
                  inout vec4 uva2,
                  inout vec4 uva3,
                  inout vec4 uva4)
{
    vec3 ambient = clamp(materialAmbient * lightAmbient + materialEmissive, kZero3, kOne3);
    vec4 diffuse = clamp(materialDiffuse * vec4(lightDiffuse, 1.0), kZero4, kOne4);
    color = vec4(clamp(ambient + dot(normal, -lightDirection) * diffuse.rgb, kZero3, kOne3), diffuse.a);
}

} /* handleVertex */

GLSLShader mainObjectVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec2 vpvl2_inTexCoord;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;
in vec4 vpvl2_inUVA1;
in vec4 vpvl2_inUVA2;
in vec4 vpvl2_inUVA3;
in vec4 vpvl2_inUVA4;
out vec4 vpvl2_outOrigin;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outShadowPosition;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec4 vpvl2_outColor;
out vec3 vpvl2_outNormal;

void handleVertex(const vec4 origin, inout vec4 position, inout vec3 normal, inout vec4 texcoord, inout vec4 color, inout vec4 uva1, inout vec4 uva2, inout vec4 uva3, inout vec4 uva4);
vec4 performPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 performNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

const vec4 kBlack = vec4(vec3(0.0), 1.0);
const vec2 kHalf2 = vec2(0.5);
const vec2 kOne2  = vec2(1.0);

void main() {
    vec4 origin   = performPositionTransform(vpvl2_inPosition, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vec3 normal   = (normalMatrix * performNormalTransform(vpvl2_inNormal, vpvl2_inPosition, vpvl2_inBoneIndices, vpvl2_inBoneWeights)).xyz;
    vec4 position = modelViewProjectionMatrix * origin;
    vec4 texcoord = vpvl2_inTexCoord.xyxy;
    vec4 color    = kBlack;
    vec4 uva1     = vpvl2_inUVA1;
    vec4 uva2     = vpvl2_inUVA2;
    vec4 uva3     = vpvl2_inUVA3;
    vec4 uva4     = vpvl2_inUVA4;
    texcoord.zw   = (-normal.xy * kHalf2 + kHalf2) * vec2(use_spheremap)
                  + (kOne2 + vec2(dot(lightDirection.xyz, -normal)) * kHalf2) * vec2(!use_spheremap);
    handleVertex(origin, position, normal, texcoord, color, uva1, uva2, uva3, uva4);
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = lightViewProjectionMatrix * origin;
    vpvl2_outTexCoord       = texcoord;
    vpvl2_outColor          = color;
    vpvl2_outUVA1           = uva1;
    vpvl2_outUVA2           = uva2;
    vpvl2_outUVA3           = uva3;
    vpvl2_outUVA4           = uva4;
    vpvl2_outNormal         = normal;
    gl_Position             = position;
}

} /* GLSLShader mainObjectVS */

GLSLShader global noPixelColor {

const vec4 kZero4 = vec4(0.0);

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{                      
    return kZero4;
}

} /* noPixelColor */

GLSLShader outputPixelColor {

vec4 applyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1);
vec4 applyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal);

const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    vec4 newColor = applyToon(applyTexture(color, texcoord, uva1), shadowPosition, normal);
    vec3 halfVector = normalize((cameraPosition - origin.xyz) - lightDirection);
    vec3 specular = clamp(materialSpecular * lightSpecular, kZero3, kOne3);
    float hdotn = max(dot(halfVector, normal), 0.0);
    newColor.rgb += specular * vec3(pow(hdotn, max(materialShininess, 1.0)));
    // newColor.a *= opacity;
    return newColor;
}

} /* outputPixelColor */


GLSLShader outputEdgeColor {

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    return edgeColor;
}

} /* outputEdgeColor */

GLSLShader outputShadowColor {

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    return vec4(materialAmbient, materialDiffuse.a);
}

} /* outputShadowColor */

GLSLShader outputZplot {

#if __VERSION__ < 130
#define in varying
#endif

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4)
{
    float depth = position.z / position.w;
    return vec4(depth, depth * depth, 0, 1);
}

} /* outputZplot */

GLSLShader mainObjectPS {

#if __VERSION__ < 130
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#else
layout(location=0) out vec4 vpvl2_outPixelColor;
#endif
in vec4 vpvl2_outOrigin;
in vec4 vpvl2_outPosition;
in vec4 vpvl2_outShadowPosition;
in vec4 vpvl2_outTexCoord;
in vec4 vpvl2_outColor;
in vec4 vpvl2_outUVA1;
in vec4 vpvl2_outUVA2;
in vec4 vpvl2_outUVA3;
in vec4 vpvl2_outUVA4;
in vec3 vpvl2_outNormal;

vec4 outputPixelColor(const vec4 origin,
                      const vec4 position,
                      const vec3 normal,
                      const vec4 texcoord,
                      const vec4 color,
                      const vec4 shadowPosition,
                      const vec4 uva1,
                      const vec4 uva2,
                      const vec4 uva3,
                      const vec4 uva4);

void main() {
    vpvl2_outPixelColor = outputPixelColor(vpvl2_outOrigin,
                                           vpvl2_outPosition,
                                           normalize(vpvl2_outNormal),
                                           vpvl2_outTexCoord,
                                           vpvl2_outColor,
                                           vpvl2_outShadowPosition,
                                           vpvl2_outUVA1,
                                           vpvl2_outUVA2,
                                           vpvl2_outUVA3,
                                           vpvl2_outUVA4);
}

} /* GLSLShader mainObjectPS */

GLSLShader mainEdgeVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;

out vec4 vpvl2_outOrigin;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outShadowPosition;
out vec4 vpvl2_outColor;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec3 vpvl2_outNormal;
out vec3 vpvl2_outEyeView;

const vec4 kZero4 = vec4(0.0);
const vec3 kZero3 = vec3(0.0);

vec4 performEdgeTransform(const vec4 position, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights);

void main() {
    vec4 origin             = performEdgeTransform(vpvl2_inPosition, vpvl2_inNormal, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vec4 position           = modelViewProjectionMatrix * origin;
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = kZero4;
    vpvl2_outTexCoord       = kZero4;
    vpvl2_outColor          = kZero4;
    vpvl2_outUVA1           = kZero4;
    vpvl2_outUVA2           = kZero4;
    vpvl2_outUVA3           = kZero4;
    vpvl2_outUVA4           = kZero4;
    vpvl2_outEyeView        = kZero3;
    vpvl2_outNormal         = vpvl2_inNormal.xyz;
    gl_Position             = position;
}

} /* GLSLShader mainEdgeVS */

GLSLShader mainShadowVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;

out vec4 vpvl2_outOrigin;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outShadowPosition;
out vec4 vpvl2_outColor;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec3 vpvl2_outNormal;
out vec3 vpvl2_outEyeView;

const vec4 kZero4 = vec4(0.0);
const vec3 kZero3 = vec3(0.0);

vec4 performPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void main() {
    vec4 origin             = performPositionTransform(vpvl2_inPosition, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vec4 position           = modelViewProjectionMatrix * origin;
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = kZero4;
    vpvl2_outTexCoord       = kZero4;
    vpvl2_outColor          = kZero4;
    vpvl2_outUVA1           = kZero4;
    vpvl2_outUVA2           = kZero4;
    vpvl2_outUVA3           = kZero4;
    vpvl2_outUVA4           = kZero4;
    vpvl2_outEyeView        = kZero3;
    vpvl2_outNormal         = vpvl2_inNormal.xyz;
    gl_Position             = position;
}

} /* GLSLShader mainShadowVS */

GLSLShader mainZplotVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;

out vec4 vpvl2_outOrigin;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outShadowPosition;
out vec4 vpvl2_outColor;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec3 vpvl2_outNormal;
out vec3 vpvl2_outEyeView;

const vec4 kZero4 = vec4(0.0);
const vec3 kZero3 = vec3(0.0);

vec4 performPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void main() {
    vec4 origin             = performPositionTransform(vpvl2_inPosition, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vec4 position           = lightViewProjectionMatrix * origin;
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = kZero4;
    vpvl2_outTexCoord       = kZero4;
    vpvl2_outColor          = kZero4;
    vpvl2_outUVA1           = kZero4;
    vpvl2_outUVA2           = kZero4;
    vpvl2_outUVA3           = kZero4;
    vpvl2_outUVA4           = kZero4;
    vpvl2_outEyeView        = kZero3;
    vpvl2_outNormal         = vpvl2_inNormal.xyz;
    gl_Position             = position;
}

} /* GLSLShader mainZplotVS */

GLSLShader global drawQuadVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif

in vec4 Position;
in vec3 TexCoord;
out vec3 vpvl2_TexCoord;

void main() {
    vpvl2_TexCoord = TexCoord;
    gl_Position    = Position;
}

} /* drawQuadVS */

GLSLShader global drawQuadPS {

#if __VERSION__ < 130
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#ifndef texture
#define texture texture2D
#endif
#else
layout(location=0) out vec4 vpvl2_outPixelColor;
#endif

uniform sampler2D vpvl2_sampler;
in vec3 vpvl2_TexCoord;

void main() {
    vpvl2_outPixelColor = texture(vpvl2_sampler, vpvl2_TexCoord.xy);
}

} /* drawQuadPS */

} /* namespace vpvl2 */

technique vpvl2_techniques_Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object1 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object2 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object3 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object4 {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object5 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object6 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object7 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object8 {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS1 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = { 
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS2 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS3 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS4 {
        SamplerState(toonSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS5 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS6 {
        SamplerState(mainSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS7 {
        SamplerState(sphereSampler) = vpvl2::defaultSamplerState;
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_ObjectSS8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS8 {
        SamplerState(depthSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(depthSampler) = 3;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::handleVertex;
        VertexProgram<"transformGroupObject"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::outputPixelColor;
    }
}

technique vpvl2_techniques_Edge < MMDPass = "edge"; > {
    pass DrawPass_Edge {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainEdgeVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupEdge"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupEdge"> = vpvl2::outputEdgeColor;
    }
}

technique vpvl2_techniques_Shadow < MMDPass = "shadow"; > {
    pass DrawPass_Shadow {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainShadowVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupShadow"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupShadow"> = vpvl2::outputShadowColor;
    }
}

technique vpvl2_techniques_Zplot < MMDPass = "zplot"; > {
    pass DrawPass_Zplot {
        SamplerState(boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::mainZplotVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"transformGroupZplot"> = vpvl2::performTransform;
        FragmentProgram<"fragmentGroupZplot"> = vpvl2::outputZplot;
    }
}

