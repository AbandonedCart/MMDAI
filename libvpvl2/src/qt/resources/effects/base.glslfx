uniform mat4 modelViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Camera"; >;
uniform mat4 lightViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Light"; >;
uniform mat4 normalMatrix              : WORLD;
uniform vec3 materialAmbient    : AMBIENT < Object = "Geometry"; >;
uniform vec4 materialDiffuse    : DIFFUSE < Object = "Geometry"; >;
uniform vec3 materialEmissive   : EMISSIVE < Object = "Geometry"; >;
uniform vec3 materialSpecular   : SPECULAR < Object = "Geometry"; >;
uniform float materialShininess : SPECULARPOWER < Object = "Geometry"; >;
uniform vec3 lightAmbient       : AMBIENT < Object = "Light"; >;
uniform vec3 lightDiffuse       : DIFFUSE < Object = "Light"; >;
uniform vec3 lightSpecular      : SPECULAR < Object = "Light"; >;
uniform vec3 cameraPosition     : _POSITION < Object = "Camera"; >;
uniform vec3 lightDirection     : DIRECTION < Object = "Light"; >;

uniform sampler2D mainSampler   : MATERIALTEXTURE;
uniform sampler2D toonSampler   : MATERIALTOONTEXTURE;
uniform sampler2D sphereSampler : MATERIALSPHERETEXTURE;
uniform sampler2D depthSampler  : TEXUNIT0;

uniform bool use_texture;
uniform bool use_toon;
uniform bool use_spheremap;
uniform bool isSPHTexture;
uniform bool isSPATexture;
uniform bool isSubTexture;

SamplerState defaultSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultToonSamplerState
{
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}
SamplerState defaultDepthSamplerState
{
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}

GLSLShader {

const float kOne = 1.0;
const float kHalf = 0.5;
const float kZero = 0.0;

vec3 saturate3(vec3 value) {
    return clamp(value, vec3(kZero), vec3(kOne));
}
vec4 saturate4(vec4 value) {
    return clamp(value, vec4(kZero), vec4(kOne));
}

}

GLSLShader ObjectVS {
#if __VERSION__ < 130
#define in attribute
#define out varying
#endif
in vec3 inPosition;
in vec3 inNormal;
in vec2 inTexCoord;
in vec4 inUVA0;
in vec4 inUVA1;
out vec4 outColor;
out vec4 outTexCoord;
out vec4 outShadowPosition;
out vec4 outUVA1;
out vec3 outEyeView;
out vec3 outNormal;

vec2 makeSphereMap(const vec3 normal) {
    return vec2(normal.x * kHalf + kHalf, normal.y * kHalf + kHalf);
}

vec2 calculateToon(const vec3 normal) {
    return (vec3(kOne, kOne, kOne) + dot(lightDirection.xyz, -normal) * kHalf).xy;
}

void main() {
    vec4 position = vec4(inPosition, kOne);
    vec3 normal = (normalMatrix * vec4(inNormal, 0)).xyz;
    vec3 ambient = saturate3(materialAmbient * lightAmbient + materialEmissive);
    vec4 diffuse = saturate4(materialDiffuse * vec4(lightDiffuse, kOne));
    outEyeView = cameraPosition.xyz - inPosition;
    outNormal = inNormal;
    outColor.rgb = saturate3(ambient + dot(inNormal, -lightDirection) * diffuse.rgb);
    outColor.a = diffuse.a;
    outTexCoord.xy = inTexCoord + inUVA0.xy;
    outTexCoord.zw = use_spheremap ? makeSphereMap(normal) : calculateToon(normal);
    outUVA1 = inUVA1;
    gl_Position = modelViewProjectionMatrix * position;
}
}

GLSLShader ObjectSSVS {
#if __VERSION__ < 130
#define in attribute
#define out varying
#endif
in vec3 inPosition;
in vec3 inNormal;
in vec2 inTexCoord;
in vec4 inUVA0;
in vec4 inUVA1;
out vec4 outColor;
out vec4 outTexCoord;
out vec4 outShadowPosition;
out vec4 outUVA1;
out vec3 outEyeView;
out vec3 outNormal;

vec2 makeSphereMap(const vec3 normal) {
    return vec2(normal.x * kHalf + kHalf, normal.y * kHalf + kHalf);
}

vec2 calculateToon(const vec3 normal) {
    return (vec3(kOne) + dot(lightDirection.xyz, -normal) * kHalf).xy;
}

void main() {
    vec4 position = vec4(inPosition, kOne);
    vec3 normal = (normalMatrix * vec4(inNormal, 0)).xyz;
    vec3 ambient = saturate3(materialAmbient * lightAmbient + materialEmissive);
    vec4 diffuse = saturate4(materialDiffuse * vec4(lightDiffuse, kOne));
    outEyeView = cameraPosition.xyz - inPosition;
    outNormal = inNormal;
    outColor.rgb = saturate3(ambient + dot(inNormal, -lightDirection) * diffuse.rgb);
    outColor.a = diffuse.a;
    outTexCoord.xy = inTexCoord + inUVA0.xy;
    outTexCoord.zw = use_spheremap ? makeSphereMap(normal) : calculateToon(normal);
    outUVA1 = inUVA1;
    outShadowPosition = lightViewProjectionMatrix * position;
    gl_Position = modelViewProjectionMatrix * position;
}
}

GLSLShader ObjectPS {
#ifdef GL_ES
precision highp float;
#endif
#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#define texture(samp, uv) texture2D((samp), (uv))
#else
out vec4 outPixelColor;
#endif
in vec4 outColor;
in vec4 outTexCoord;
in vec4 outShadowPosition;
in vec4 outUVA1;
in vec3 outEyeView;
in vec3 outNormal;

vec4 applyTexture(const vec4 color) {
    vec4 textureColor = vec4(kOne, kOne, kOne, kOne);
    if (use_texture) {
        textureColor = texture(mainSampler, outTexCoord.xy);
    }
    if (use_spheremap) {
        if (isSPHTexture) {
            textureColor.rgb *= texture(sphereSampler, outTexCoord.zw).rgb;
        }
        else if (isSPATexture) {
            textureColor.rgb += texture(sphereSampler, outTexCoord.zw).rgb;
        }
        else if (isSubTexture) {
            textureColor.rgb *= texture(sphereSampler, outUVA1.xy).rgb;
        }
    }
    return color * textureColor;
}

void main() {
    vec4 color = applyTexture(outColor);
    vec3 normal = normalize(outNormal);
    if (use_toon) {
        const vec2 kToonTexCoord = vec2(kZero, kOne);
        vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
        vec3 toonColor = toonColorRGBA.rgb;
        float lightNormal = dot(normal, -lightDirection.xyz);
        float w = clamp(lightNormal * 16.0 + kHalf, kZero, kOne);
        color.rgb *= toonColor + (vec3(kOne, kOne, kOne) - toonColor) * w;
    }
    vec3 halfVector = normalize(normalize(outEyeView) - lightDirection);
    vec3 specular = saturate3(materialSpecular * lightSpecular);
    float hdotn = max(dot(halfVector, normal), kZero);
    color.rgb += specular * pow(hdotn, max(materialShininess, kOne));
    // color.a *= opacity;
    outPixelColor = color;
}
}

GLSLShader ObjectSSPS {
#ifdef GL_ES
precision highp float;
#endif
#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#define texture(samp, uv) texture2D((samp), (uv))
#else
out vec4 outPixelColor;
#endif
in vec4 outColor;
in vec4 outTexCoord;
in vec4 outShadowPosition;
in vec4 outUVA1;
in vec3 outEyeView;
in vec3 outNormal;

vec4 applyTexture(const vec4 color) {
    vec4 textureColor = vec4(kOne, kOne, kOne, kOne);
    if (use_texture) {
        textureColor = texture(mainSampler, outTexCoord.xy);
    }
    if (use_spheremap) {
        if (isSPHTexture) {
            textureColor.rgb *= texture(sphereSampler, outTexCoord.zw).rgb;
        }
        else if (isSPATexture) {
            textureColor.rgb += texture(sphereSampler, outTexCoord.zw).rgb;
        }
        else if (isSubTexture) {
            textureColor.rgb *= texture(sphereSampler, outUVA1.xy).rgb;
        }
    }
    return color * textureColor;
}

float getShadowFactor(const vec4 position) {
    const float kEpsilonBias = 0.00001;
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vec2((shadowPosition.xy * kHalf) + kHalf);
#if 0 /* VSM */
    vec2 depthSample = texture(depthSampler, shadowCoord).rg;
    float sigma = (depthSample.y - depthSample.x * depthSample.x) + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = max(min(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)), 1.0), 0.0);
#else
    float depthSample = texture(depthSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

void main() {
    vec3 normal = normalize(outNormal);
    vec4 color = applyTexture(outColor);
    vec4 shadowColor = color;
    float shadowFactor = getShadowFactor(outShadowPosition);
    if (use_toon) {
        const vec2 kToonTexCoord = vec2(kZero, kOne);
        vec4 toonColorRGBA = texture(toonSampler, kToonTexCoord);
        vec3 toonColor = toonColorRGBA.rgb;
        shadowColor.rgb *= toonColor;
        color.rgb = shadowColor.rgb + (color.rgb - shadowColor.rgb) * (kOne - shadowFactor);
    }
    else {
        shadowColor.rgb *= materialAmbient;
        color.rgb = shadowColor.rgb + (color.rgb - shadowColor.rgb) * (kOne - shadowFactor);
    }
    vec3 halfVector = normalize(normalize(outEyeView) - lightDirection);
    vec3 specular = saturate3(materialSpecular * lightSpecular);
    float hdotn = max(dot(halfVector, normal), kZero);
    color.rgb += specular * pow(hdotn, max(materialShininess, kOne));
    // color.a *= opacity;
    outPixelColor = color;
}
}

GLSLShader EdgeVS {
#if __VERSION__ < 130
#define in attribute
#endif
in vec3 inPosition;

void main() {
    gl_Position = modelViewProjectionMatrix * vec4(inPosition, kOne);
}
}

GLSLShader EdgePS {
#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif
#ifdef GL_ES
precision lowp float;
#endif

in vec4 outColor;

void main() {
    vec4 color = vec4(0, 0, 0, 1);
    // color.a *= opacity;
    outPixelColor = color;
}
}

GLSLShader ZplotVS {
#if __VERSION__ < 130
#define in attribute
#define out varying
#endif
in vec3 inPosition;
out vec4 outPosition;

void main() {
    vec4 position = lightViewProjectionMatrix * vec4(inPosition, kOne);
    outPosition = position;
    gl_Position = position;
}
}

GLSLShader ZplotPS {
#if __VERSION__ < 130
#define in varying
#define outPixelColor gl_FragColor
#else
out vec4 outPixelColor;
#endif
#ifdef GL_ES
precision highp float;
#endif

in vec4 outPosition;

void main() {
    float depth = outPosition.z / outPosition.w;
    vec4 color = vec4(depth, depth * depth, 0, 1);
    // color.a *= opacity;
    outPixelColor = color;
}
}

technique Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        VertexProgram = ObjectVS;
        FragmentProgram = ObjectPS;
    }
}

technique ObjectWithSelfShadow1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(toonSampler) = defaultToonSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(toonSampler) = 2;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(mainSampler) = defaultSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(mainSampler) = 0;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(sphereSampler) = defaultSamplerState;
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(sphereSampler) = 1;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique ObjectWithSelfShadow8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    Attribute(inPosition) = 0;
    Attribute(inNormal)   = 1;
    Attribute(inTexCoord) = 2;
    pass DrawPass {
        SamplerState(depthSampler) = defaultDepthSamplerState;
        SamplerTexUnit(depthSampler) = 3;
        VertexProgram = ObjectSSVS;
        FragmentProgram = ObjectSSPS;
    }
}

technique Edge < MMDPass = "edge"; > {
    Attribute(inPosition) = 0;
    pass DrawPass {
        VertexProgram = EdgeVS;
        FragmentProgram = EdgePS;
    }
}

technique Zplot < MMDPass = "zplot"; > {
    Attribute(inPosition) = 0;
    pass DrawPass {
        VertexProgram = ZplotVS;
        FragmentProgram = ZplotPS;
    }
}

