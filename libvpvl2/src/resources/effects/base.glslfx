uniform bool use_texture;
uniform bool use_spheremap;
uniform bool use_toon;
uniform bool spadd;
uniform bool spsub;
uniform float VertexCount;
uniform float SubsetCount;
uniform int BoneCountVPVL2;
uniform bool use_boneTransformTextureVPVL2;

namespace vpvl2 {

uniform mat4 worldViewMatrix           : WORLDVIEW < Object = "Camera"; >;
uniform mat4 projectionMatrix          : PROJECTION < Object = "Camera"; >;
uniform mat4 worldViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Camera"; >;
uniform mat4 lightViewProjectionMatrix : WORLDVIEWPROJECTION < Object = "Light"; >;
uniform vec3 materialAmbient           : AMBIENT < Object = "Geometry"; >;
uniform vec4 materialDiffuse           : DIFFUSE < Object = "Geometry"; >;
uniform vec3 materialEmissive          : EMISSIVE < Object = "Geometry"; >;
uniform vec3 materialSpecular          : SPECULAR < Object = "Geometry"; >;
uniform float materialShininess        : SPECULARPOWER < Object = "Geometry"; >;
uniform vec3 lightAmbient              : AMBIENT < Object = "Light"; >;
uniform vec3 lightDiffuse              : DIFFUSE < Object = "Light"; >;
uniform vec3 lightSpecular             : SPECULAR < Object = "Light"; >;
uniform vec3 cameraPosition            : POSITION < Object = "Camera"; >;
uniform vec3 lightDirection            : DIRECTION < Object = "Light"; >;
uniform vec4 edgeColor                 : EDGECOLOR;
uniform float edgeWidth                : EDGEWIDTH;

uniform sampler2D mainTextureSampler   : MATERIALTEXTURE;
uniform sampler2D toonTextureSampler   : MATERIALTOONTEXTURE;
uniform sampler2D sphereTextureSampler : MATERIALSPHEREMAP;
uniform sampler2D depthTextureSampler  : TEXUNIT0;

uniform sampler2D boneTransformSampler : BONETRANSFORMTEXTUREVPVL2;
uniform float edgeScaleFactor          : EDGESCALEFACTORVPVL2;

SamplerState defaultLinearFilterSamplerState {
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultNearestFilterSamplerState {
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
}
SamplerState defaultLinearFilterMipmapSamplerState {
    TEXTURE_MIN_FILTER = LINEAR_MIPMAP_LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
}
SamplerState defaultToonSamplerState {
    TEXTURE_MIN_FILTER = LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}
SamplerState defaultDepthSamplerState {
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
}

GLSLShader global performTransform {

#if __VERSION__ < 130
#ifndef texture
#define texture texture2D
#endif
#endif

const mat4 kIdenticalMatrix = mat4(1.0);
const int kBdef1 = 0;
const int kBdef2 = 1;
const int kBdef4 = 2;
const int kSdef  = 3;
const int kQdef  = 4;

mat4 vpvl2FXGetBoneTransformMatrix(const float index) {
    float newIndex = index / float(BoneCountVPVL2);
    mat4 matrix = kIdenticalMatrix;
    vec4 p = texture(vpvl2_NS_boneTransformSampler, vec2(0.0,  newIndex));
    vec4 q = texture(vpvl2_NS_boneTransformSampler, vec2(0.5,  newIndex));
    matrix[0] = vec4(
        1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,
        2.0 * q.x * q.y + 2.0 * q.w * q.z,
        2.0 * q.x * q.z - 2.0 * q.w * q.y,
        0.0
    );
    matrix[1] = vec4(
        2.0 * q.x * q.y - 2.0 * q.w * q.z,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,
        2.0 * q.y * q.z + 2.0 * q.w * q.x,
        0.0
    );
    matrix[2] = vec4(
        2.0 * q.x * q.z + 2.0 * q.w * q.y,
        2.0 * q.y * q.z - 2.0 * q.w * q.x,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y,
        0.0
    );
    matrix[3] = p;
    return matrix;
}

vec4 vpvl2FXPerformSkinning(const vec3 origin3, const vec4 boneIndices, const vec4 boneWeights, const float base, const int type) {
    vec4 origin = vec4(origin3, base);
    bool bdef4  = any(bvec2(type == kBdef4, type == kQdef));
    bool bdef2  = any(bvec2(type == kBdef2, type == kSdef));
    if (type == kBdef1) {
        mat4 matrix = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        return matrix * origin;
    }
    else if (bdef2) {
        mat4 matrix1 = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        mat4 matrix2 = vpvl2FXGetBoneTransformMatrix(boneIndices.y);
        vec4 p1 = matrix2 * origin;
        vec4 p2 = matrix1 * origin;
        return mix(p1, p2, boneWeights.x);
    }
    else if (bdef4) {
        mat4 matrix1 = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        mat4 matrix2 = vpvl2FXGetBoneTransformMatrix(boneIndices.y);
        mat4 matrix3 = vpvl2FXGetBoneTransformMatrix(boneIndices.z);
        mat4 matrix4 = vpvl2FXGetBoneTransformMatrix(boneIndices.w);
        return boneWeights.xxxx * (matrix1 * origin)
             + boneWeights.yyyy * (matrix2 * origin)
             + boneWeights.zzzz * (matrix3 * origin)
             + boneWeights.wwww * (matrix4 * origin);
    }
    return origin;
}

vec4 vpvl2FXPerformPositionTransform(const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        return vpvl2FXPerformSkinning(origin.xyz, boneIndices, boneWeights, 1.0, int(origin.w));
    }
    return vec4(origin.xyz, 1.0);
}

vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        return vpvl2FXPerformSkinning(normal.xyz, boneIndices, boneWeights, 0.0, int(origin.w));
    }
    return vec4(normal.xyz, 0.0);
}

vec4 vpvl2FXPerformEdgeTransform(const vec4 origin, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        int type         = int(origin.w);
        vec4 newPosition = vpvl2FXPerformSkinning(origin.xyz, boneIndices, boneWeights, 1.0, type);
        vec4 newNormal   = vpvl2FXPerformSkinning(normal.xyz, boneIndices, boneWeights, 0.0, type);
        newPosition.xyz += newNormal.xyz * normal.www * vec3(vpvl2_NS_edgeWidth * vpvl2_NS_edgeScaleFactor);
        return newPosition;
    }
    return vec4(origin.xyz, 1.0);
}

} /* performTransform */

GLSLShader global applyTexture {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
    vec4 newColor = color;
    if (use_texture) {
        newColor *= texture(vpvl2_NS_mainTextureSampler, texcoord.xy);
    }
    if (use_spheremap) {
        if (spadd) {
            newColor.rgb += texture(vpvl2_NS_sphereTextureSampler, texcoord.zw).rgb;
        }
        else if (spsub) {
            newColor.rgb *= texture(vpvl2_NS_sphereTextureSampler, uva1.xy).rgb;
        }
        else {
            newColor.rgb *= texture(vpvl2_NS_sphereTextureSampler, texcoord.zw).rgb;
        }
    }
    return newColor;
}

} /* applyTexture */

GLSLShader global noApplyTexture {

vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
     return color;
}

} /* noApplyTexture */

GLSLShader global applyToon {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const vec2 kToonTexCoord = vec2(0.0, 1.0);
const vec3 kWhiteColor = vec3(1.0);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor = mix(vec4(1.0), texture(vpvl2_NS_toonTextureSampler, kToonTexCoord), float(use_toon));
    float w = clamp(dot(normal, -vpvl2_NS_lightDirection) * 16.0 + 0.5, 0.0, 1.0);
    vec4 newColor = color;
    newColor.rgb *= toonColor.rgb + (kWhiteColor - toonColor.rgb) * vec3(w);
    return newColor;
}

} /* applyToon */

GLSLShader global noApplyToon {

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
     return color;
}

} /* noApplyToon */

GLSLShader global getShadowFactor {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const float kEpsilonBias = 0.00001;

float vpvl2FXGetShadowFactor(const vec4 position) {
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vec2((shadowPosition.xy * 0.5) + 0.5);
#if 0 /* VSM */
    vec2 depthSample = texture(depthTextureSampler, shadowCoord).rg;
    float sigma = depthSample.y - depthSample.x * depthSample.x + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = clamp(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)), 0.0, 1.0);
#else
    float depthSample = texture(vpvl2_NS_depthTextureSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

} /* getShadowFactor */

GLSLShader global applyToonSelfShadow {

#if __VERSION__ < 130
#ifndef texture
#define texture(samp, uv) texture2D((samp), (uv))
#endif
#endif

const vec2 kToonTexCoord = vec2(0.0, 1.0);

float vpvl2FXGetShadowFactor(const vec4 position);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor   = mix(vec4(1.0), texture(vpvl2_NS_toonTextureSampler, kToonTexCoord), float(use_toon));
    vec3 shadowColor = color.rgb * toonColor.rgb;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - vpvl2FXGetShadowFactor(shadowPosition)), color.a);
}

} /* applyToonSelfShadow */

GLSLShader global applySelfShadow {

float vpvl2FXGetShadowFactor(const vec4 position);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec3 shadowColor = color.rgb * vpvl2_NS_materialAmbient;
    return vec4(shadowColor + (color.rgb - shadowColor) * vec3(1.0 - vpvl2FXGetShadowFactor(shadowPosition)), color.a);
}

} /* applySelfShadow */

GLSLShader global applyStandardLight {

const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);

vec4 vpvl2FXApplyStandardLight(const vec4 color, const vec4 origin, const vec3 normal) {
    vec3 halfVector = normalize((vpvl2_NS_cameraPosition - origin.xyz) - vpvl2_NS_lightDirection);
    vec3 specular = clamp(vpvl2_NS_materialSpecular * vpvl2_NS_lightSpecular, kZero3, kOne3);
    float hdotn = max(dot(halfVector, normal), 0.0);
    vec4 newColor = color;
    newColor.rgb += specular * vec3(pow(hdotn, max(vpvl2_NS_materialShininess, 1.0)));
    return newColor;
}

}

GLSLShader transformVertex {

const vec2 kHalf2 = vec2(0.5);
const vec2 kOne2  = vec2(1.0);
const vec3 kZero3 = vec3(0.0);
const vec3 kOne3  = vec3(1.0);
const vec4 kZero4 = vec4(0.0);
const vec4 kOne4  = vec4(1.0);

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    vec3 ambient = clamp(vpvl2_NS_materialAmbient * vpvl2_NS_lightAmbient + vpvl2_NS_materialEmissive, kZero3, kOne3);
    vec4 diffuse = clamp(vpvl2_NS_materialDiffuse * vec4(vpvl2_NS_lightDiffuse, 1.0), kZero4, kOne4);
    origin       = vpvl2FXPerformPositionTransform(origin, boneIndices, boneWeights);
    position     = vpvl2_NS_worldViewProjectionMatrix * origin;
    normal       = vpvl2_NS_worldViewMatrix * vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    color        = vec4(clamp(ambient + dot(normal.xyz, -vpvl2_NS_lightDirection) * diffuse.rgb, kZero3, kOne3), diffuse.a);
    texcoord.zw  = (-normal.xy * kHalf2 + kHalf2) * vec2(use_spheremap)
                 + (kOne2 + vec2(dot(vpvl2_NS_lightDirection, -normal.xyz)) * kHalf2) * vec2(!use_spheremap);
}

} /* transformVertex */

GLSLShader transformVertexEdge {

vec4 vpvl2FXPerformEdgeTransform(const vec4 origin, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    origin   = vpvl2FXPerformEdgeTransform(origin, normal, boneIndices, boneWeights);
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    position = vpvl2_NS_worldViewProjectionMatrix * origin;
}

} /* transformVertexEdge */

GLSLShader transformVertexShadow {

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    origin   = vpvl2FXPerformPositionTransform(origin, boneIndices, boneWeights);
    position = vpvl2_NS_worldViewProjectionMatrix * origin;
}

} /* transformVertexShadow */

GLSLShader transformVertexZplot {

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    origin   = vpvl2FXPerformPositionTransform(position, boneIndices, boneWeights);
    position = vpvl2_NS_lightViewProjectionMatrix * origin;
}

} /* transformVertexZplot */

GLSLShader global discardVertex {

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    origin = position = normal = vec4(0.0);
}

} /* discardVertex */

GLSLShader mainObjectVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif
in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec2 vpvl2_inTexCoord;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;
in vec4 vpvl2_inUVA1;
in vec4 vpvl2_inUVA2;
in vec4 vpvl2_inUVA3;
in vec4 vpvl2_inUVA4;
out vec4 vpvl2_outOrigin;
out vec3 vpvl2_outNormal;
out vec4 vpvl2_outPosition;
out vec4 vpvl2_outShadowPosition;
out vec4 vpvl2_outTexCoord;
out vec4 vpvl2_outUVA1;
out vec4 vpvl2_outUVA2;
out vec4 vpvl2_outUVA3;
out vec4 vpvl2_outUVA4;
out vec4 vpvl2_outColor;

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights);

const vec4 kBlack = vec4(vec3(0.0), 1.0);

void main() {
    vec4 origin   = vpvl2_inPosition;
    vec4 position = origin;
    vec4 normal   = vpvl2_inNormal;
    vec4 texcoord = vpvl2_inTexCoord.xyxy;
    vec4 color    = kBlack;
    vec4 uva1     = vpvl2_inUVA1;
    vec4 uva2     = vpvl2_inUVA2;
    vec4 uva3     = vpvl2_inUVA3;
    vec4 uva4     = vpvl2_inUVA4;
    vpvl2FXTransformVertex(origin, position, normal, texcoord, color, uva1, uva2, uva3, uva4, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = vpvl2_NS_lightViewProjectionMatrix * origin;
    vpvl2_outNormal         = normal.xyz;
    vpvl2_outTexCoord       = texcoord;
    vpvl2_outColor          = color;
    vpvl2_outUVA1           = uva1;
    vpvl2_outUVA2           = uva2;
    vpvl2_outUVA3           = uva3;
    vpvl2_outUVA4           = uva4;
    gl_Position             = position;
}

} /* GLSLShader mainObjectVS */

GLSLShader global passThroughFragment {

const vec4 kZero4 = vec4(0.0);

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{                      
    return kZero4;
}

} /* passThroughFragment */

GLSLShader global transformFragment {

vec4 vpvl2FXApplyStandardLight(const vec4 color, const vec4 origin, const vec3 normal);
vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1);
vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal);

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    vec4 newColor = vpvl2FXApplyStandardLight(vpvl2FXApplyToon(vpvl2FXApplyTexture(color, texcoord, uva1), shadowPosition, normal), origin, normal);
    // newColor.a *= opacity;
    return newColor;
}

} /* transformFragment */


GLSLShader global transformFragmentEdge {

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    return vpvl2_NS_edgeColor;
}

} /* transformFragmentEdge */

GLSLShader global transformFragmentShadow {

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    return vec4(vec3(0.0), vpvl2_NS_materialDiffuse.a);
}

} /* transformFragmentShadow */

GLSLShader global transformFragmentZplot {

#if __VERSION__ < 130
#define in varying
#endif

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    float depth = position.z / position.w;
    return vec4(depth, 0, 0, 1);
}

} /* transformFragmentZplot */

GLSLShader mainObjectPS {

#if __VERSION__ < 130
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#else
layout(location=0) out vec4 vpvl2_outPixelColor;
#endif
in vec4 vpvl2_outOrigin;
in vec4 vpvl2_outPosition;
in vec4 vpvl2_outShadowPosition;
in vec4 vpvl2_outTexCoord;
in vec4 vpvl2_outColor;
in vec4 vpvl2_outUVA1;
in vec4 vpvl2_outUVA2;
in vec4 vpvl2_outUVA3;
in vec4 vpvl2_outUVA4;
in vec3 vpvl2_outNormal;

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4);

void main() {
    vpvl2_outPixelColor = vpvl2FXTransformFragment(vpvl2_outOrigin,
                                                   vpvl2_outPosition,
                                                   normalize(vpvl2_outNormal),
                                                   vpvl2_outTexCoord,
                                                   vpvl2_outColor,
                                                   vpvl2_outShadowPosition,
                                                   vpvl2_outUVA1,
                                                   vpvl2_outUVA2,
                                                   vpvl2_outUVA3,
                                                   vpvl2_outUVA4);
}

} /* GLSLShader mainObjectPS */

GLSLShader global drawQuadVS {

#if __VERSION__ < 130
#define in attribute
#define out varying
#else
out gl_PerVertex {
    vec4 gl_Position;
};
#endif

in vec4 Position;
in vec3 TexCoord;
out vec3 vpvl2_drawQuadTexCoord;

void main() {
    vpvl2_drawQuadTexCoord = TexCoord;
    gl_Position            = Position;
}

} /* drawQuadVS */

GLSLShader global drawQuadPS {

#if __VERSION__ < 130
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#ifndef texture
#define texture texture2D
#endif
#else
layout(location=0) out vec4 vpvl2_outPixelColor;
#endif

uniform sampler2D vpvl2_drawQuadTextureSampler;
in vec3 vpvl2_drawQuadTexCoord;

void main() {
    vpvl2_outPixelColor = texture(vpvl2_drawQuadTextureSampler, vpvl2_drawQuadTexCoord.xy);
}

} /* drawQuadPS */

} /* namespace vpvl2 */

technique vpvl2_techniques_Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object1 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object2 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object3 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object4 {
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object5 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object6 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object7 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object8 {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS1 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = { 
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS2 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS3 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS4 {
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS5 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS6 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS7 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS8 {
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Edge < MMDPass = "edge"; > {
    pass DrawPass_Edge {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupEdge"> = vpvl2::transformVertexEdge;
        FragmentProgram<"fragmentGroupEdge"> = vpvl2::transformFragmentEdge;
    }
}

technique vpvl2_techniques_Shadow < MMDPass = "shadow"; > {
    pass DrawPass_Shadow {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupShadow"> = vpvl2::transformVertexShadow;
        FragmentProgram<"fragmentGroupShadow"> = vpvl2::transformFragmentShadow;
    }
}

technique vpvl2_techniques_Zplot < MMDPass = "zplot"; > {
    pass DrawPass_Zplot {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupZplot"> = vpvl2::transformVertexZplot;
        FragmentProgram<"fragmentGroupZplot"> = vpvl2::transformFragmentZplot;
    }
}

