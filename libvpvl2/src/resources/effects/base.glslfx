#include ":vpvl2/declarations.glslfxh"

namespace vpvl2 {

GLSLShader global performTransform {

const mat4 kIdenticalMatrix = mat4(1.0);
const int kBdef1 = 0;
const int kBdef2 = 1;
const int kBdef4 = 2;
const int kSdef  = 3;
const int kQdef  = 4;

mat4 vpvl2FXCreateMatrix4FromQuaternion(const vec4 p, const vec4 q) {
    mat4 matrix;
    matrix[0] = vec4(
        1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,
        2.0 * q.x * q.y + 2.0 * q.w * q.z,
        2.0 * q.x * q.z - 2.0 * q.w * q.y,
        0.0
    );
    matrix[1] = vec4(
        2.0 * q.x * q.y - 2.0 * q.w * q.z,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,
        2.0 * q.y * q.z + 2.0 * q.w * q.x,
        0.0
    );
    matrix[2] = vec4(
        2.0 * q.x * q.z + 2.0 * q.w * q.y,
        2.0 * q.y * q.z - 2.0 * q.w * q.x,
        1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y,
        0.0
    );
    matrix[3] = p;
    return matrix;
}

mat4 vpvl2FXGetBoneTransformMatrix(const float index) {
    float newIndex = index / float(BoneCountVPVL2);
    mat4 matrix = kIdenticalMatrix;
    vec4 p = vpvl2FXGetTexturePixel2D(vpvl2_NS_boneTransformSampler, vec2(0.0,  newIndex));
    vec4 q = vpvl2FXGetTexturePixel2D(vpvl2_NS_boneTransformSampler, vec2(0.5,  newIndex));
    return vpvl2FXCreateMatrix4FromQuaternion(p, q);
}

vec4 vpvl2FXPerformSkinning(const vec3 origin3, const vec4 boneIndices, const vec4 boneWeights, const float base, const int type) {
    vec4 origin   = vec4(origin3, base);
    bvec2 isBdef4 = bvec2(type == kBdef4, type == kQdef);
    bvec2 isBdef2 = bvec2(type == kBdef2, type == kSdef);
    bool hasBdef4 = any(isBdef4);
    bool hasBdef2 = any(isBdef2);
    if (type == kBdef1) {
        mat4 matrix = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        return matrix * origin;
    }
    else if (hasBdef2) {
        mat4 matrix1 = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        mat4 matrix2 = vpvl2FXGetBoneTransformMatrix(boneIndices.y);
        vec4 p1 = matrix2 * origin;
        vec4 p2 = matrix1 * origin;
        return mix(p1, p2, boneWeights.x);
    }
    else if (hasBdef4) {
        mat4 matrix1 = vpvl2FXGetBoneTransformMatrix(boneIndices.x);
        mat4 matrix2 = vpvl2FXGetBoneTransformMatrix(boneIndices.y);
        mat4 matrix3 = vpvl2FXGetBoneTransformMatrix(boneIndices.z);
        mat4 matrix4 = vpvl2FXGetBoneTransformMatrix(boneIndices.w);
        return vpvl2FXFMA(boneWeights.xxxx, (matrix1 * origin),
               vpvl2FXFMA(boneWeights.yyyy, (matrix2 * origin),
               vpvl2FXFMA(boneWeights.zzzz, (matrix3 * origin),
                   boneWeights.wwww + (matrix4 * origin))));
    }
    return origin;
}

vec4 vpvl2FXPerformPositionTransform(const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    return mix(vec4(origin.xyz, 1.0), vpvl2FXPerformSkinning(origin.xyz, boneIndices, boneWeights, 1.0, int(origin.w)), float(use_boneTransformTextureVPVL2));
}

vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 origin, const vec4 boneIndices, const vec4 boneWeights) {
    return mix(vec4(normal.xyz, 0.0), vpvl2FXPerformSkinning(normal.xyz, boneIndices, boneWeights, 0.0, int(origin.w)), float(use_boneTransformTextureVPVL2));
}

vec4 vpvl2FXPerformEdgeTransform(const vec4 origin, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights) {
    if (use_boneTransformTextureVPVL2) {
        int type         = int(origin.w);
        vec4 newPosition = vpvl2FXPerformSkinning(origin.xyz, boneIndices, boneWeights, 1.0, type);
        vec4 newNormal   = vpvl2FXPerformSkinning(normal.xyz, boneIndices, boneWeights, 0.0, type);
        vec3 newEdgeSize = vec3(vpvl2_NS_edgeWidth * vpvl2_NS_edgeScaleFactor);
        newPosition.xyz += newNormal.xyz * normal.www * newEdgeSize;
        return newPosition;
    }
    return vec4(origin.xyz, 1.0);
}

} /* performTransform */

GLSLShader global applyTexture {

vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
    vec4 newColor = mix(color, color * vpvl2FXGetTexturePixel2D(vpvl2_NS_mainTextureSampler, texcoord.xy), float(use_texture));
    if (use_spheremap) {
        if (spadd) {
            newColor.rgb += vpvl2FXGetTexturePixel2D(vpvl2_NS_sphereTextureSampler, texcoord.zw).rgb;
        }
        else if (spsub) {
            newColor.rgb *= vpvl2FXGetTexturePixel2D(vpvl2_NS_sphereTextureSampler, uva1.xy).rgb;
        }
        else {
            newColor.rgb *= vpvl2FXGetTexturePixel2D(vpvl2_NS_sphereTextureSampler, texcoord.zw).rgb;
        }
    }
    return newColor;
}

} /* applyTexture */

GLSLShader global noApplyTexture {

vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1) {
     return color;
}

} /* noApplyTexture */

GLSLShader global applyToon {

const vec4 kOne4 = vec4(1.0);
const vec3 kWhiteColor = vec3(1.0);
const vec2 kToonTexCoord = vec2(0.0, 1.0);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor = mix(kOne4, vpvl2FXGetTexturePixel2D(vpvl2_NS_toonTextureSampler, kToonTexCoord), float(use_toon));
    vec4 newColor  = color;
    float w        = vpvl2FXSaturate(vpvl2FXFMA(dot(normal, -vpvl2_NS_lightDirection), 16.0, 0.5));
    newColor.rgb  *= vpvl2FXFMA(kWhiteColor - toonColor.rgb, vec3(w), toonColor.rgb);
    return newColor;
}

} /* applyToon */

GLSLShader global noApplyToon {

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 newColor = color;
    return newColor;
}

} /* noApplyToon */

GLSLShader global getShadowFactor {

const float kEpsilonBias = 0.00001;
const vec2  kHalf2 = vec2(0.5, 0.5);

float vpvl2FXGetShadowFactor(const vec4 position) {
    vec4 shadowPosition = position / position.w;
    vec2 shadowCoord = vpvl2FXFMA(shadowPosition.xy, kHalf2, kHalf2);
#if 0 /* VSM */
    vec2 depthSample = vpvl2FXGetTexturePixel2D(depthTextureSampler, shadowCoord).rg;
    float sigma = depthSample.y - depthSample.x * depthSample.x + kEpsilonBias;
    float delta = depthSample.x - shadowPosition.z;
    float p = sigma / (sigma + (delta * delta));
    float shadowFactor = vpvl2FXSaturate(max(p, float((depthSample.x + kEpsilonBias) < shadowPosition.z)));
#else
    float depthSample = vpvl2FXGetTexturePixel2D(vpvl2_NS_depthTextureSampler, shadowCoord).r;
    float shadowFactor = float((depthSample + kEpsilonBias) < shadowPosition.z);
#endif
    return shadowFactor;
}

} /* getShadowFactor */

GLSLShader global applyToonSelfShadow {

const vec4 kOne4 = vec4(1.0);
const vec2 kToonTexCoord = vec2(0.0, 1.0);

float vpvl2FXGetShadowFactor(const vec4 position);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec4 toonColor   = mix(kOne4, vpvl2FXGetTexturePixel2D(vpvl2_NS_toonTextureSampler, kToonTexCoord), float(use_toon));
    vec3 shadowColor = color.rgb * toonColor.rgb;
    return vec4(vpvl2FXFMA(color.rgb - shadowColor, vec3(1.0 - vpvl2FXGetShadowFactor(shadowPosition)), shadowColor), color.a);
}

} /* applyToonSelfShadow */

GLSLShader global applySelfShadow {

float vpvl2FXGetShadowFactor(const vec4 position);

vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal) {
    vec3 shadowColor = color.rgb * vpvl2_NS_materialAmbient;
    return vec4(vpvl2FXFMA(color.rgb - shadowColor, vec3(1.0 - vpvl2FXGetShadowFactor(shadowPosition)), shadowColor), color.a);
}

} /* applySelfShadow */

GLSLShader global applyStandardLight {

vec4 vpvl2FXApplyStandardLight(const vec4 color, const vec4 origin, const vec3 normal) {
    vec3 halfVector = normalize((vpvl2_NS_cameraPosition - origin.xyz) - vpvl2_NS_lightDirection);
    vec3 specular = vpvl2FXSaturate(vpvl2_NS_materialSpecular * vpvl2_NS_lightSpecular);
    float hdotn = max(dot(halfVector, normal), 0.0);
    vec4 newColor = color;
    newColor.rgb += specular * vec3(pow(hdotn, max(vpvl2_NS_materialShininess, 1.0)));
    return newColor;
}

}

GLSLShader global transformVertex {

const vec2 kOne2  = vec2(1.0);
const vec2 kHalf2 = vec2(0.5);

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    origin            = vpvl2FXPerformPositionTransform(origin, boneIndices, boneWeights);
    position          = vpvl2_NS_worldViewProjectionMatrix * origin;
    normal            = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    vec3 ambientColor = vpvl2FXFMA(vpvl2_NS_materialAmbient, vpvl2_NS_lightAmbient, vpvl2_NS_materialEmissive);
    vec4 diffuseColor = vpvl2_NS_materialDiffuse * vec4(vpvl2_NS_lightDiffuse, 1.0);
    vec3 lightDiffuse = vec3(vpvl2FXSaturate(dot(normal.xyz, -vpvl2_NS_lightDirection)) * float(!use_toon));
    vec3 colorRGB     = vpvl2FXFMA(lightDiffuse, diffuseColor.rgb, ambientColor);
    color             = vpvl2FXSaturate(vec4(colorRGB, diffuseColor.a));
    texcoord.zw       = mix(vpvl2FXFMA(vec2(dot(vpvl2_NS_lightDirection, -normal.xyz)), kHalf2, kOne2), vpvl2FXFMA(-normal.xy, kHalf2, kHalf2), float(use_spheremap));
}

} /* transformVertex */

GLSLShader global transformVertexEdge {

vec4 vpvl2FXPerformEdgeTransform(const vec4 origin, const vec4 normal, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    origin   = vpvl2FXPerformEdgeTransform(origin, normal, boneIndices, boneWeights);
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    position = vpvl2_NS_worldViewProjectionMatrix * origin;
}

} /* transformVertexEdge */

GLSLShader global transformVertexShadow {

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    origin   = vpvl2FXPerformPositionTransform(origin, boneIndices, boneWeights);
    position = vpvl2_NS_worldViewProjectionMatrix * origin;
}

} /* transformVertexShadow */

GLSLShader global transformVertexZplot {

vec4 vpvl2FXPerformPositionTransform(const vec4 position, const vec4 boneIndices, const vec4 boneWeights);
vec4 vpvl2FXPerformNormalTransform(const vec4 normal, const vec4 position, const vec4 boneIndices, const vec4 boneWeights);

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    normal   = vpvl2FXPerformNormalTransform(normal, position, boneIndices, boneWeights);
    origin   = vpvl2FXPerformPositionTransform(position, boneIndices, boneWeights);
    position = vpvl2_NS_lightViewProjectionMatrix * origin;
}

} /* transformVertexZplot */

GLSLShader global discardVertex {

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights)
{
    origin = position = normal = vec4(0.0);
}

} /* discardVertex */

GLSLShader global mainObjectVS {

#if __VERSION__ >= 130
out gl_PerVertex {
    vec4 gl_Position;
};
#else
#define in attribute
#define out varying
#endif

in vec4 vpvl2_inPosition;
in vec4 vpvl2_inNormal;
in vec2 vpvl2_inTexCoord;
in vec4 vpvl2_inBoneIndices;
in vec4 vpvl2_inBoneWeights;
in vec4 vpvl2_inUVA1;
in vec4 vpvl2_inUVA2;
in vec4 vpvl2_inUVA3;
in vec4 vpvl2_inUVA4;

layout(location=1)  out vec4 vpvl2_outOrigin;
layout(location=2)  out vec4 vpvl2_outPosition;
layout(location=3)  out vec3 vpvl2_outNormal;
layout(location=4)  out vec4 vpvl2_outTexCoord;
layout(location=5)  out vec4 vpvl2_outColor;
layout(location=6)  out vec4 vpvl2_outShadowPosition;
layout(location=7)  out vec4 vpvl2_outUVA1;
layout(location=8)  out vec4 vpvl2_outUVA2;
layout(location=9)  out vec4 vpvl2_outUVA3;
layout(location=10) out vec4 vpvl2_outUVA4;

void vpvl2FXTransformVertex(inout vec4 origin,
                            inout vec4 position,
                            inout vec4 normal,
                            inout vec4 texcoord,
                            inout vec4 color,
                            inout vec4 uva1,
                            inout vec4 uva2,
                            inout vec4 uva3,
                            inout vec4 uva4,
                            const vec4 boneIndices,
                            const vec4 boneWeights);

const vec4 kBlack = vec4(vec3(0.0), 1.0);

void main() {
    vec4 origin   = vpvl2_inPosition;
    vec4 position = origin;
    vec4 normal   = vpvl2_inNormal;
    vec4 texcoord = vpvl2_inTexCoord.xyxy;
    vec4 color    = kBlack;
    vec4 uva1     = vpvl2_inUVA1;
    vec4 uva2     = vpvl2_inUVA2;
    vec4 uva3     = vpvl2_inUVA3;
    vec4 uva4     = vpvl2_inUVA4;
    vpvl2FXTransformVertex(origin, position, normal, texcoord, color, uva1, uva2, uva3, uva4, vpvl2_inBoneIndices, vpvl2_inBoneWeights);
    vpvl2_outOrigin         = origin;
    vpvl2_outPosition       = position;
    vpvl2_outShadowPosition = vpvl2_NS_lightViewProjectionMatrix * origin;
    vpvl2_outNormal         = normal.xyz;
    vpvl2_outTexCoord       = texcoord;
    vpvl2_outColor          = color;
    vpvl2_outUVA1           = uva1;
    vpvl2_outUVA2           = uva2;
    vpvl2_outUVA3           = uva3;
    vpvl2_outUVA4           = uva4;
    gl_Position             = position;
}

} /* GLSLShader mainObjectVS */

GLSLShader global passThroughFragment {

const vec4 kZero4 = vec4(0.0);

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{                      
    return kZero4;
}

} /* passThroughFragment */

GLSLShader global transformFragment {

vec4 vpvl2FXApplyStandardLight(const vec4 color, const vec4 origin, const vec3 normal);
vec4 vpvl2FXApplyTexture(const vec4 color, const vec4 texcoord, const vec4 uva1);
vec4 vpvl2FXApplyToon(const vec4 color, const vec4 shadowPosition, const vec3 normal);

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    vec4 newColor = vpvl2FXApplyTexture(color, texcoord, uva1);
    newColor = vpvl2FXApplyToon(newColor, shadowPosition, normal);
    newColor = vpvl2FXApplyStandardLight(newColor, origin, normal);
    // newColor.a *= opacity;
    return vpvl2FXSaturate(newColor);
}

} /* transformFragment */


GLSLShader global transformFragmentEdge {

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    return vpvl2_NS_edgeColor;
}

} /* transformFragmentEdge */

GLSLShader global transformFragmentShadow {

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    return vec4(vec3(0.0), vpvl2_NS_materialDiffuse.a);
}

} /* transformFragmentShadow */

GLSLShader global transformFragmentZplot {

#if __VERSION__ < 130
#define in varying
#endif

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4)
{
    float depth = position.z / position.w;
    return vec4(depth, 0, 0, 1);
}

} /* transformFragmentZplot */

GLSLShader global mainObjectPS {

#if __VERSION__ >= 130
layout(location=0) out vec4 vpvl2_outPixelColor;
#else
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#endif

layout(location=1)  in vec4 vpvl2_outOrigin;
layout(location=2)  in vec4 vpvl2_outPosition;
layout(location=3)  in vec3 vpvl2_outNormal;
layout(location=4)  in vec4 vpvl2_outTexCoord;
layout(location=5)  in vec4 vpvl2_outColor;
layout(location=6)  in vec4 vpvl2_outShadowPosition;
layout(location=7)  in vec4 vpvl2_outUVA1;
layout(location=8)  in vec4 vpvl2_outUVA2;
layout(location=9)  in vec4 vpvl2_outUVA3;
layout(location=10) in vec4 vpvl2_outUVA4;

vec4 vpvl2FXTransformFragment(const vec4 origin,
                              const vec4 position,
                              const vec3 normal,
                              const vec4 texcoord,
                              const vec4 color,
                              const vec4 shadowPosition,
                              const vec4 uva1,
                              const vec4 uva2,
                              const vec4 uva3,
                              const vec4 uva4);

void main() {
    vpvl2_outPixelColor = vpvl2FXTransformFragment(vpvl2_outOrigin,
                                                   vpvl2_outPosition,
                                                   normalize(vpvl2_outNormal),
                                                   vpvl2_outTexCoord,
                                                   vpvl2_outColor,
                                                   vpvl2_outShadowPosition,
                                                   vpvl2_outUVA1,
                                                   vpvl2_outUVA2,
                                                   vpvl2_outUVA3,
                                                   vpvl2_outUVA4);
}

} /* GLSLShader mainObjectPS */

GLSLShader global drawQuadVS {

#if __VERSION__ >= 130
out gl_PerVertex {
    vec4 gl_Position;
};
#else
#define in attribute
#define out varying
#endif

in vec4 Position;
in vec3 TexCoord;
out vec3 vpvl2_drawQuadTexCoord;

void main() {
    vpvl2_drawQuadTexCoord = TexCoord;
    gl_Position            = Position;
}

} /* drawQuadVS */

GLSLShader global drawQuadPS {

#if __VERSION__ >= 130
layout(location=0) out vec4 vpvl2_outPixelColor;
#else
#define in varying
#define vpvl2_outPixelColor gl_FragColor
#endif

uniform sampler2D vpvl2_drawQuadTextureSampler;
in vec3 vpvl2_drawQuadTexCoord;

void main() {
    vpvl2_outPixelColor = vpvl2FXGetTexturePixel2D(vpvl2_drawQuadTextureSampler, vpvl2_drawQuadTexCoord.xy);
}

} /* drawQuadPS */

} /* namespace vpvl2 */

technique vpvl2_techniques_Object1 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object1 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object2 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object2 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object3 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_Object3 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object4 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_Object4 {
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object5 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object5 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object6 < MMDPass = "object"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object6 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object7 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_Object7 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::applyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Object8 < MMDPass = "object"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_Object8 {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::noApplyToon,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS1 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS1 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = { 
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS2 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS2 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS3 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 1; > {
    pass DrawPass_ObjectSS3 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS4 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 1; > {
    pass DrawPass_ObjectSS4 {
        SamplerState(vpvl2::toonTextureSampler) = vpvl2::defaultToonSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::toonTextureSampler) = 2;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applyToonSelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS5 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS5 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS6 < MMDPass = "object_ss"; UseTexture = 1; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS6 {
        SamplerState(vpvl2::mainTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::mainTextureSampler) = 0;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS7 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 1; UseToon = 0; > {
    pass DrawPass_ObjectSS7 {
        SamplerState(vpvl2::sphereTextureSampler) = vpvl2::defaultLinearFilterSamplerState;
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::sphereTextureSampler) = 1;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::applyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_ObjectSS8 < MMDPass = "object_ss"; UseTexture = 0; UseSphereMap = 0; UseToon = 0; > {
    pass DrawPass_ObjectSS8 {
        SamplerState(vpvl2::depthTextureSampler) = vpvl2::defaultDepthSamplerState;
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::depthTextureSampler) = 3;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::applyStandardLight,
            vpvl2::noApplyTexture,
            vpvl2::getShadowFactor,
            vpvl2::applySelfShadow,
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupObject"> = vpvl2::transformVertex;
        FragmentProgram<"fragmentGroupObject"> = vpvl2::transformFragment;
    }
}

technique vpvl2_techniques_Edge < MMDPass = "edge"; > {
    pass DrawPass_Edge {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupEdge"> = vpvl2::transformVertexEdge;
        FragmentProgram<"fragmentGroupEdge"> = vpvl2::transformFragmentEdge;
    }
}

technique vpvl2_techniques_Shadow < MMDPass = "shadow"; > {
    pass DrawPass_Shadow {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupShadow"> = vpvl2::transformVertexShadow;
        FragmentProgram<"fragmentGroupShadow"> = vpvl2::transformFragmentShadow;
    }
}

technique vpvl2_techniques_Zplot < MMDPass = "zplot"; > {
    pass DrawPass_Zplot {
        SamplerState(vpvl2::boneTransformSampler) = vpvl2::defaultDepthSamplerState;
        SamplerTexUnit(vpvl2::boneTransformSampler) = 4;
        VertexProgram = {
            vpvl2::performTransform,
            vpvl2::mainObjectVS
        };
        FragmentProgram = {
            vpvl2::mainObjectPS
        };
        VertexProgram<"vertexGroupZplot"> = vpvl2::transformVertexZplot;
        FragmentProgram<"fragmentGroupZplot"> = vpvl2::transformFragmentZplot;
    }
}

